# Простое веб-приложение. Async/Await, замена xhr на fetch. Сборка клиентской части.

## Цель
Лабораторная состоит из 2-х частей: 

- Первая часть данной лабораторной работы заключается в изменении механизма взаимодействия с внешним API: в прошлой лабораторной работе использовался XMLHttpRequest, в этой - современный метод `fetch`. В ходе выполнения работы предстоит познакомиться с кратким полезным теоретическим материалом,
кодом реализации простого взаимодействия с внешним API,
получением данных и выводом их в интерфейс пользователя,
и выполнить задания по варианту.

- Вторая часть лабораторной работы заключается в сборке клиентской части приложения: необходимо "сбилдить" клиентскую часть (ЛР №3) с помощью системы сборки, а также добавить в серверную часть (ЛР №4) возможность раздачи клиентской части в качестве статики во избежание проблем с CORS.

## План

Часть 1:
1. Введение в `Promise`.
2. Использование `Promise`.
3. Что такое `async await` в JS.
4. Пояснение про `fetch` и пример использования.

Часть 2:
1. Сборка клиентской части через `Vite`.
2. Раздача фронтенда в качестве статики.

## Часть 1.

### 1. Введение в `Promise`
Казалось бы, при чем здесь `promises` (промисы), если мы хотели делать запросы на сервера и изучать `fetch`?
Дело в том, что fetch работает с использованием промисов, это функция, которая возвращает `promise`.

Поэтому прежде чем говорить о том, что такое fetch и зачем он нужен, обратимся к промисам.

*Promise* - это специальный объект, который используется в языке для отложенных и асинхронных вычислений.
Прочитал(а) и ничего не понятно? Это нормально, мне тоже было в начале не ясно, попробуем вместе разобраться:

Асинхронная операция или вычисление - операция, которая выполнится в будущем, не прямо сейчас. Например - нам очень хочется посчитать сумму двух чисел,
но мы сами этого не умеем (так получилось) и для этого,
делаем запрос на сервер, чтобы он посчитал это за нас и выдал нам какой-то результат.
Запрос на сервер - это асинхронная операция, она требует какого-то времени на свое выполнение, поэтому она выполнится в будущем. На что уйдет это время?
![Фото 3](./assets/client-server-timings.jpg)
Запрос должен дойти до сервера на этой уйдет 3 сек времени, на сервере
должна выполнится какая-то простая бизнес-логика, а именно сложение двух чисел, которое займет 2 сек и отправка результата к нам обратно, на нее мы потратим еще 3 секунды.
Итого мы потратим 8 секунд на выполнение операции.

Такую операцию мы не можем выполнять последовательно, как мы привыкли. Представьте выполнение программного кода, где мы последовательно, шаг
за шагом выполняем каждую строчку кода, если мы будем
подобные долгие операции выполнять также построчно, то наш последующий код не будет выполняться пока мы не дождемся ответа от сервера,
мы не сможем делать никаких других действий, пока нам не вернется результат.
Так делать нельзя! Для этого и придумали механизм промисов - механизм "обещаний".

Промис - специальный объект, который обещает, что уведомит тебя о своем завершении, когда это произойдет.
У промиса есть 3 состояния, в которых он может находится:
1. Pending - ожидание, это начальное состояние, промис выполняется, но результат еще не известен
2. Fulfilled - промис выполнен успешно, результат получен
3. Rejected - промис отклонен, произошла какая-то ошибка или сбой во время выполнения

Синтаксис создания такого объекта прост:
```ts
new Promise((resolve, reject) => {
    //... функция которая будет определять состояние промиса, логику, по которой он будет переходить
    //... из pending -> fulfilled или из pending -> rejected
    
    // resolve - функция, вызов которой переводит промис из состояния  pending -> fulfilled
    resolve() // вот таким образом "обещание" выполнится и мы отдадим конкретное значение, переведем промис в состояние fulfilled
    
    // reject - - функция, вызов которой переводит промис из состояния  pending -> rejected
    reject() // вот таким образом "обещание" вернет ошибку, оно скажет "Прости, я сломался". Так мы переведем промис в состояние rejected
    
})
```

Возникает вопрос: "Круто, мы поняли про состояния промиса, но как мне отследить изменение состояния?
Как понять, что он был pending, а стал fulfilled, как это в коде описать?"

Для этого у промисов существуют следюущие методы (методы - это функции классов):

1. `then()`
Наиболее распростроненный метод используется следующим образом
```ts
// promise - объект промиса
promise.then(
  function(result) { /* обработает успешное выполнение */ },
  function(error) { /* обработает ошибку */ }
);
```
Метод `then()` говорит нам следюущее, когда промис выполнится упешно вызови первую функцию, иначе вызови вторую. Мы сами вольны написать, что делать в первой, а что делать во второй
Таким образом, `then` позволит понять, когда промис перейдет из состояния pending -> fulfilled.

2. `catch()`
Это метод, который позволяет нам удобно отловить ошибку, по факту это сокращение для удобства. Он делает тоже самое, что и вторая функция в методе `then`
Иными словами, написать
```ts
// выводит ошибку в случае неуспеха
promise.then(null, (error) => {console.log(error)})
```
Это тоже самое, что написать 
```ts
// выводит ошибку в случае неуспеха
promise.catch((error) => {console.log(error)})
```

3. `finally()`
Еще один метод у промисов, в него также можно передать функцию - коллбек. Коллбек, переданный в метод будет вызван вне зависимости от результата промиса.


### 2. Использование `Promise`
Выше мы рассмотрели промисы, давайте поймем как их можно использовать на примере:

```ts
const promise = new Promise((resolve, reject) => {
    // мы сгенерировали рандомное число
    const randNumber = Math.random() * 100; // return number from 0 to 100
    
    // заводим таймаут, чтобы промис перешел в новое состояние только через 10 секунд
    setTimeout(() => {
        // тут мы проверяем, что если число больше 20 получилось, то мы переводим промис в fulfilled, иначе в rejected
        if (randNumber > 20) {
            resolve();
        } else {
            reject();
        }
    }, 10000);
})
```
Таким образом, промис пробудет в состоянии `pending` - 10 секунд, после чего он выполнится либо успешно (`funlfilled`) с вероятностью 80 процентов или с ошибкой (`rejected`).

Обрабатывать результат работы с ним мы будем с помощью методов промиса:

```ts
promise
    .then(() => {console.log('Победа')}) // сюда попадаем в случае успеха
    .catch(() => {console.log('ПРоизошла ошибка')}) // сюда в случае ошибки
    .finally(() => {console.log('Закончили')}) // сюда всегда попадаем в конце
```

### 3. Что такое `async await` в JS
Выше мы для обработки результата промиса использовали "цепочку" из then и catch. Такое порой сложно читать и долго писать.
Для этого в JS существует сочетание `async await`. Это "синтаксический сахар" языка, упрощающий жизнь разработчиков.
Приведем пример:

```ts
const getDataFromServer = () => {
    return new Promise((resolve, reject) => {
        // мы сгенерировали рандомное число
        const randNumber = Math.random() * 100; // return number from 0 to 100

        // заводим таймаут, чтобы промис перешел в новое состояние только через 10 секунд
        setTimeout(() => {
            // тут мы проверяем, что если число больше 20 получилось, то мы переводим промис в fulfilled, иначе в rejected
            if (randNumber > 20) {
                resolve('успех');
            } else {
                reject('ашибка!');
            }
        }, 10000);
    }).then(result => console.log(result))
        .catch(console.log)
}
```

Вместо этого можно написать вот так:
```ts
const getDataFromServer = async () => {
    // вместо then и catch мы используем блок try {} catch {}
    try {
        
        const result = await new Promise((resolve, reject) => {
            // мы сгенерировали рандомное число
            const randNumber = Math.random() * 100; // return number from 0 to 100

            // заводим таймаут, чтобы промис перешел в новое состояние только через 10 секунд
            setTimeout(() => {
                // тут мы проверяем, что если число больше 20 получилось, то мы переводим промис в fulfilled, иначе в rejected
                if (randNumber > 20) {
                    resolve('успех');
                } else {
                    reject('ашибка!');
                }
            }, 10000);
        });
        // эта строчка кода не выполнится до тех пор, пока не станет известным результат промиса, который выше
        console.log(result);
    } catch (err) {
        console.log(err);
    }
}
```

### 4. Пояснение про `fetch` и пример использования
`fetch` - функция для выполнения запросов в браузере, которая возвращает нам промис. [подробная документация](https://learn.javascript.ru/fetch)

Помните в прошлой лабораторной работе мы от АПИ получали список карточек? 
Как это происходило там, мы использовали XMLHttpRequest, который работает с использованием коллбеков или же отложенных функций.
Код выглядел примерно так:
```ts
    let xhr = new XMLHttpRequest()
    xhr.onload = () => {
        //...делаем какую-то логику, когда данные получили
    }
    
    xhr.onerror = () => {
        // ...делаем другую логику, в случае когда все пошло не поплану
        // отвалился интернет, сервер перестал отвечать на запросы и т.д
    }
    
    xhr.open('POST', getUrl(url))
    xhr.send();
```
Механика работы XMLHttpRequest заключалась в том, что мы описывали какие функции надо вызвать в случае возникновения события.
Например на загрузку данных мы вызывали функцию onLoad, а в случае ошибки будет вызываться функция onError.
Не было такой механики, как промисы в данном случае.

Теперь же, мы бы написали функцию следующим образом

```ts
    const getDataFromServer = async () => {
       try { 
           //Делаем GET запрос на указанный урл
           const result = await fetch('yandex.ru');
           
           // возвращаем результат в случае успеха
           return result;
       } catch (e) {
           console.log(e);
       }
}
```
## Часть 2

### 1. Сборка клиентской части через `Vite`.

[Vite ](https://vite.dev/) - современная популярная система сборки для фронтенд приложений. [Добавим](https://vite.dev/guide/#manual-installation) `vite` в проект клиентской части с карточками (ЛР №3).

1. Перейдем в папку с фронтендом:

```bash
cd your-lab3-folder
```

2. Установим `vite`:

```bash
npm install -D vite
```

3. Добавим команды в `package.json`:

```json
// package.json
{
    "scripts": {
        "dev": "vite", // start dev server, aliases: `vite dev`, `vite serve`
        "build": "vite build", // build for production
        "preview": "vite preview" // locally preview production build
    }
}
```

4. Добавим `vite.config.js`:

```js
// vite.config.js
export default {
    build: {
        outDir: './public',
        emptyOutDir: true,
    },
};
```

Готово!

Выполним `npm run dev` и зайдем на `http://localhost:5173/`, чтобы убедиться, что все работает (бекенд должен быть предварительно запущен).
![Dev](assets/dev.png)

Выполнив `npm run build`, убедимся, что появляется папка `public` с собранной клиентской частью:
![alt text](assets/build-public.png)

Также можно посмотреть превью сборки, выполнив команду `npm run preview`. В этом режиме фронтенд запускается в production-режиме, из результатов сборки в `public`.

Dev-режим (запуск через `vite` - ` npm run dev` или vs-code плагин`live-server`):
![Before structure](assets/before-structure-dev.png)

Preview-режим (запуск через `vite` - `npm run preview`):
![alt text](assets/after-structure-public.png)

## 2. Раздача фронтенда в качестве статики.

Если сейчас зайти на `http://localhost:3000/`, то ничего отображаться не будет и более того, будет ошибка:
![Not found](assets/not-found.png)

Чтобы бекенд раздавал клиентскую часть в качестве статики нужно выполнить несколько действий:

1. Скопировать папку сборки `public` в проект с бекендом:
   ![Public in backend](assets/public-in-backend.png)

2. Указать при запуске NestJS сервера, что нужно раздавать содержимое `public` в качестве статики:

```ts
// main.ts
...
import { NestExpressApplication } from '@nestjs/platform-express';
import { resolve } from 'path';

async function bootstrap() {
  const app = await NestFactory.create<NestExpressApplication>(AppModule);

  app.useStaticAssets(resolve(__dirname, '..', 'public'));

  await app.listen(process.env.PORT ?? 3000);
}

...
```

-   `app.useStaticAssets(resolve(__dirname, '..', 'public'));` - указывает приложению путь к ассетам

-   Дополнительно нужно указать дженерик `NestExpressApplication` при создании экземляра приложения, чтобы ts понимал, что в качестве низкоуровневого фреймворка используется `express` (`useStaticAssets` как раз метод express-сервера)

Готово!

Если перезапустить NestJS сервер и зайти на `http://localhost:3000/`, можно убедиться, что теперь и карточки отображаются, и запросы выполняются и нет нужды обходить CORS, поскольку запросы выполняются с того же домена.
![Frontend and backend](assets/frontend-and-backend.png)

Итоговая структура приложения с бекендом из ЛР №4:
![Final backend](assets/final-backend.png)

## Дополнительные материалы

Вам необходимо доработать предыдущую лабораторную работу. Также по своему варинту, вам нужно заменить все вызовы и использования
XMLHttpRequest на fetch.